# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11Z841DAKf0AO3f9jMcv0nmCx7WxNiElu
"""

!pip install obspy scipy pywt matplotlib numpy

!pip install git+https://github.com/PyWavelets/pywt.git

!pip install git+https://github.com/PyWavelets/pywt.git



!pip install --upgrade --force-reinstall obspy

# === Install dependencies (Colab) ===
#!pip install obspy numpy scipy matplotlib pandas pywt

# === Imports ===
import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import detrend, butter, filtfilt
from scipy.integrate import cumulative_trapezoid

from obspy.signal.trigger import classic_sta_lta, trigger_onset
import pywt
from datetime import datetime

!head -n 40 /content/TK4615-n.6000jllz.HNZ.--.acc.V2c

with open(path) as f:
    for i in range(60):  # show first 60 lines after header
        print(f.readline().strip())

import numpy as np

acceleration = []
path="/content/TK4615-n.6000jllz.HNE.--.acc.V2c"
with open(path) as f:
    data_started = False
    for line in f:
        line = line.strip()
        if not data_started:
            # Look for line where actual acceleration values start
            if line.startswith("12686 acceleration pts"):
                data_started = True
                continue
        else:
            if not line or line.startswith("|"):  # skip empty or comment lines
                continue
            try:
                value = float(line)
                if value != -999:  # ignore missing-value placeholders
                    acceleration.append(value)
            except ValueError:
                continue

acceleration = np.array(acceleration)
print("Number of valid acceleration points:", len(acceleration))
print("First 10 points:", acceleration[:10])

import matplotlib.pyplot as plt

# Basic statistics
print("Min:", acceleration.min())
print("Max:", acceleration.max())
print("Mean:", acceleration.mean())

# Plot first 1000 points
plt.figure(figsize=(12,4))
plt.plot(acceleration[:1000])
plt.title("Acceleration Time Series (First 1000 points)")
plt.xlabel("Sample Index")
plt.ylabel("Acceleration (cm/s²)")
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, detrend

# Use your loaded acceleration data
data = acceleration

# Sampling parameters
fs = 100.0  # Hz
lowcut, highcut = 0.1, 40.0  # Hz

# Bandpass filter design
b, a = butter(4, [lowcut/(0.5*fs), highcut/(0.5*fs)], btype='band')

# Detrend and filter
filtered_acc = filtfilt(b, a, detrend(data))

# Plot first 5000 samples
plt.figure(figsize=(12,4))
plt.plot(filtered_acc[:5000])
plt.title("Filtered Acceleration (first 5000 samples)")
plt.xlabel("Sample index")
plt.ylabel("Acceleration (cm/s²)")
plt.show()

import pywt
import numpy as np
import matplotlib.pyplot as plt

# Use filtered acceleration
acc = filtered_acc

# Wavelet parameters
wavelet = 'db4'
max_level = pywt.dwt_max_level(len(acc), pywt.Wavelet(wavelet).dec_len)

# Perform DWT
coeffs = pywt.wavedec(acc, wavelet, level=max_level)

# Calculate energy in each sub-band
energies = [np.sum(np.square(c)) for c in coeffs]
print("Wavelet energy per level:", energies)

# Plot detail coefficients for each level
plt.figure(figsize=(12, 2*(len(coeffs)-1)))
for i, c in enumerate(coeffs[1:], 1):  # skip approximation coeffs at index 0
    plt.subplot(len(coeffs)-1, 1, i)
    plt.plot(c)
    plt.ylabel(f'Level {i}')
    plt.grid(True)
plt.xlabel('Sample index')
plt.suptitle(f'Detail Coefficients (Wavelet: {wavelet})', fontsize=16)
plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def wavelet_cf(coeffs, signal_length):
    """
    Compute normalized characteristic function (CF) from wavelet detail coefficients.

    Parameters:
    - coeffs: list of wavelet coefficients (from pywt.wavedec)
    - signal_length: length of the original signal

    Returns:
    - cf: normalized CF of length signal_length
    """
    # Use only detail coefficients (skip approximation at coeffs[0])
    energy = np.array([np.sum(np.square(c)) for c in coeffs[1:]])

    # Interpolate energy to match original signal length
    cf = np.interp(np.arange(signal_length), np.linspace(0, signal_length, len(energy)), energy)

    # Normalize
    return cf / np.max(cf)

# Compute CF
cf = wavelet_cf(coeffs, len(acc))

# Detection threshold (mean + std)
threshold = np.mean(cf) + np.std(cf)

# Detected earthquake samples
detections = np.where(cf > threshold)[0]

# Plot CF and detections
plt.figure(figsize=(12,5))
plt.plot(cf, label='Characteristic Function (CF)')
plt.axhline(threshold, color='r', linestyle='--', label='Threshold')
plt.scatter(detections, cf[detections], color='orange', s=20, label='Detections')
plt.title("Wavelet-based Earthquake Detection")
plt.xlabel("Sample index")
plt.ylabel("Normalized CF")
plt.legend()
plt.grid(True)
plt.show()